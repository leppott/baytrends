---
title: "Vignette, QW Conversion"
author: "Erik.Leppo@tetratech.com"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette, QW}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
<!-- Data is in vignettes\data folder  -->
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
# Purpose
Early versions of the `baytrends` package relied on the `smwrQW` package for creating and using QW objects.  The `smwrQW` package has since been orphaned by its maintainer (USGS).  As such the capabilities to create and use a QW object have been ported from the `smwrQW` package into `baytrends`.  This vignette will guide users through the process to convert existing qw objects from the `smwrQW` package to the `baytrends` package (version 0.3.3.9011 or higher).

https://github.com/ldecicco-USGS/smwrQW

https://owi.usgs.gov/R/packages.html#orphan

You will need an internet connection to follow the directions below.

# Process Overview
You will need to install the `smwrQW` package (and other smwr packages), load the packages, then load the object and export the parts.  After loading the object and exporting the parts the packages need to be removed.  Only then can `baytrends` be loaded and a new qw object created from the previously exported parts.  This is because the qw object retains information about the package used to create it and will only open properly with that particular package.

An example using the dataCensored object (as an `smwrQW` qw object) is included below.  All the code is meant to be run from start to finish but comments have been added between the steps.  Many parts are automatde but running in the steps outlined below will help spot any errors.

~~~~~~~~~~~~~~~~~
* Install and load `smwrQW` packages.
* Load qw object to convert.
* Save object parts.
* Remove `smwrQW` package from computer.
* Recreate qw object from parts as a `baytrends` object.


Items to Automate
* File selection.
    + fname <- file.choose()
    + source(file.choose())
* Checking file "str()" and saving classes.
    + Classes easy.
    + Not sure what to do with things like date/time that come up as "character".
    + May have all the same columns?! 
    + If so that would be *much* easier to automate.
* Loading and removing packages.
    + Shouldn't be much of an issue.
* Dealing with unknown column headers.
    + Should be able to read and save.
    
~~~~~~~~~~~~~~~~~

# Example, dataCensored
Recreate the `smwrQW` qw object dataCensored as a `baytrends` qw object. 

Some variables may be repeated between chunks while others may not.

~~~~~~~~~~~~~~~~~~~~

Original on 2017-12-20 did not export time zone.  Thus when it was QCed and checked on 2018-01-05 the file it was missing time zone information (mix of EDT and EST).  Needed to export here with the time zone.

format(x, useTZ=TRUE)

~~~~~~~~~~~~~~~~~~~~~~~

## 1. Install Packages
Will need the smwr suite of packages installed before reading dataCensored.  All of the packages are dependant upon each other so need to have all of them installed.  They will be uninstalled in a later step.

Also ensure that have the lastest version of the `baytrends` package.

### baytrends
```{r Install_baytrends, eval=FALSE}
# Install from GitHub if dont' have it already
if(!require("baytrends")) {devtools::install_github("leppott/baytrends")}
```

### smwr Packages
```{r Example01a_Install_Pkgs_GitHub, eval=FALSE}
require(devtools)
#
# Install smwr packages (see above)
# Detect if package installed then install
myPkg <- c("smwrData", "smwrBase", "smwrGraphs", "smwrStats", "smwrQW")
for (p in myPkg) {##FOR.p.START
  #
  if(!require(p, character.only = TRUE)) {##IF.p.START
    devtools::install_github(paste0("USGS-R/", p))
  }##IF.p.END
  #
}##FOR.p.END

```

Occassionally the install from github fails.  The packages can be downloaded from GitHub and then installed from zip file.

```{r Example01a_Install_Pkgs_Zip, eval=FALSE}
Dir.Pkg <- "C:/Users/Erik.Leppo/OneDrive - Tetra Tech, Inc/MyDocs_OneDrive/ChesBay_R/_old/smwr Libraries"
myPkg <- c("smwrData", "smwrBase", "smwrGraphs", "smwrStats", "smwrQW")
myPkg.zip <- paste0(myPkg, "-master.zip")
#
lapply(myPkg.zip, function(x) install.packages(file.path(Dir.Pkg, x), repos=NULL, type="win.binary"))

```

Even with both of the above methods the packages don't get installed.  And have to go back and re-run one or the other.

## 2. Choose the file to convert.
Load the `smwrQW` package after `baytrends`.

If need to get name of an object hints are here.
http://r.789695.n4.nabble.com/Assigning-a-new-name-to-object-loaded-with-quot-load-quot-td4638144.html

```{r Example02_data0SaveHeader, eval=FALSE}
# Load after baytrends
library(smwrQW)
#
# File chooser to get file
# file.choose() is windows only.  Use tk_choose.files() for other systems.
#fn <- file.choose()
library(tcltk)
dir.qw.orig <- "C:\\Users\\Erik.Leppo\\OneDrive - Tetra Tech, Inc\\MyDocs_OneDrive\\ChesBay_R\\datasets_qw_convert"
fn <- tk_choose.files(default="dir.qw.orig", caption="Select smwr QW file to convert")
#fn <- file.path(path.package("baytrends"), "extdata", "dataCensored__qw.rda")
# baytrends package must be loaded for path.package to work
#
# load qw object
load(fn)
name.qw <- load(fn, verbose=TRUE)
# assign to a generic name so can manipulate (reassign at end)
df.qw <- get(name.qw)
```

## 3. Visually Check Structure
Visually check the object's structure.  There should be no errors. 
```{r str, eval=FALSE}
# Visually check object
name.qw
str(df.qw)
```

## 4.1. Fix Date_Time
The date and/or time need to have time zone included.

May have to manually adjust.

This will change the class from POSIXct to character.  Have to fix later.

```{r DateTime, eval=FALSE}
# Ensure date explicitly includes time zone
df.qw$date <- format(df.qw$date, format="%F %T", usetz=TRUE)
#df.qw$date <- format(df.qw$date, format="%F")
#df.qw$time <- format(df.qw$time, format="%T", usetz=TRUE)
str(df.qw)
# # convert back from char to posixct
# df.qw[,"date"] <- as.POSIXct(df.qw[,"date"])
# str(df.qw)
```


## 4. Save Header
The header are the first few variables of the data frame that are *not* of the 
qw class when examined by `str`.


Some datasets could have a field (e.g., "date") with 2 classes so have a work around of last columns as qw.
```{r Example04_data0SaveHeaderAndAll, eval=FALSE}
# Find non-qw classed columns
# (assume all qw classed columns are at the end)
class.df.ls <- lapply(df.qw, class)
class.df <- unlist(class.df.ls, use.names=FALSE)
class.df
#
# VA
# date has a 2nd class, remove
#class.df.single <- class.df[-4]
class.df.single <- class.df
class.df.single
#
# get non-qw cols
  # method 1, fails when date has 2 classes
# boo.class.qw <- class.df %in% "qw"
# col.df.QW.no <- names(df.qw)[!boo.class.qw]
  # method 2, assume qw columns at end
num.col.qw <- sum(class.df %in% "qw")
col.df.QW.no <- names(df.qw)[1:(ncol(df.qw)-num.col.qw)]
col.df.QW.yes <- names(df.qw)[!(names(df.qw) %in% col.df.QW.no)]
num.col.qw
col.df.QW.no
col.df.QW.yes
#
# header classes
class.df.single.header <- class.df.single[1:(ncol(df.qw)-num.col.qw)]
class.df.single.header

# Need export directory - 
myDir.Export.Default <- dirname(fn) #getwd()
# choose.dir is Windows only
#myDir <- choose.dir(default=myDir.Export.Default, caption="Select folder for qw slot export")
# For non-Windows use tcltk (window pops up behind RStudio)
library(tcltk)
myDir <- tk_choose.dir(myDir.Export.Default, "Choose csv output folder")

# myDir <- "C:\\Users\\Erik.Leppo\\OneDrive - Tetra Tech, Inc\\MyDocs_OneDrive\\ChesBay_R\\dataCensored_data-raw"

# Output 
# #
df.QW.no <- df.qw[,col.df.QW.no]
#df.QW.no <- df.qw[,1:8]
str(df.QW.no)
fn.header <- paste0(name.qw,"_00Header.csv")
write.csv(df.QW.no, file.path(myDir, fn.header))
# #
# # have issues
# df.QW.yes <- as.data.frame(dataCensored[,4:16])
# 
fn.all <- paste0(name.qw,"_00All.csv")
write.csv(df.qw, file.path(myDir, fn.all))
# seems to have worked

# # Visual check
# x <- read.csv("dataCensored.csv")
# str(x)


```

## 5. Extract dataCensored slot values
Save each slot in the qw object to its own CSV file.

Added error checking for each slot as not all columns have all slots.

Visually check to ensure have all header (non-qw) and data (qw) fields properly sorted.

```{r Example05_data1SaveSlots, eval=FALSE}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Loop through and save all data
#library(baytrends) #needs smwrQW library to be present
library(smwrQW)
df.qw <- df.qw
#myVar <- names(df.qw[-(1:3)])
myVar <- col.df.QW.yes
mySlotNames <- slotNames("qw")
myVar
mySlotNames
#
#
str(df.qw)
# #
#df.QW.no <- df.qw[,1:3]
df.QW.no <- df.qw[,col.df.QW.no]
str(df.QW.no)
#

#
for (i in myVar) {##FOR.i.START
  #
  i.num <- match(i, myVar)
  i.len <- length(myVar)
  #
  for (j in mySlotNames) {##FOR.j.START
    #
    j.num <- match(j, mySlotNames)
    j.len <- length(mySlotNames)
    #
    # QC for slot
    boo.slot <- .hasSlot(df.qw[,i], j)
    if (boo.slot==TRUE) {
      df.SlotValues <- slot(df.qw[,i], j)
      #
      myFile <- paste(name.qw, i, j, ".csv", sep="_")
      write.csv(df.SlotValues, file.path(myDir, myFile))
      #
      # Report Progress to User
      print(paste0("Saving; item i (",i.num,"/",i.len,") ", i,", item j (", j.num,"/",j.len,") ",j,"."))
    } else {
      print(paste0("No slot; item i (",i.num,"/",i.len,") ", i,", item j (", j.num,"/",j.len,") ",j,"."))
    }
    flush.console()
    
    #
    }#FOR.j.END
  #
}##FOR.i.END


# Unload the package
#lapply(myPkg, function(x) detach(paste0("package:", x), unload=TRUE))
detach(package:smwrData, unload=TRUE)
detach(package:smwrQW, unload=TRUE)
detach(package:smwrStats, unload=TRUE)
detach(package:smwrGraphs, unload=TRUE)
detach(package:smwrBase, unload=TRUE)

# Remove smwr* packages 
# myPkg <- c("smwrData", "smwrBase", "smwrGraphs", "smwrStats", "smwrQW")
lapply(myPkg, function(x) remove.packages(x))

```

## 6. Reconstruct the qw data object
Have a separate R script in the "data-raw" folder for generating the "dataCensored" object for the baytrends package from the raw CSV files.

convert date to POSIXct class (add EST)
DF[,"date"] <- as.POSIXct(DF[,"date"],tz="EST")

If get an error in code and need to restart from this point need to set a variable or two.

```{r PickAllDataDir, eval=FALSE}
library(tcltk)
dir.default <- "C:\\Users\\Erik.Leppo\\OneDrive - Tetra Tech, Inc\\MyDocs_OneDrive\\ChesBay_R\\datasets_qw_convert"
myDir <- tk_choose.dir(default=dir.default, caption="Select QW all data file directory to read")
#
fn <- tk_choose.files(default="dir.qw.orig", caption="Select smwr QW file to convert")
#
# Manual Stuff
#~~~~~~~~~~~~~~~~~~
# # 01, VA, Mike Lane
# class.df.single <- c("character", "character", "POSIXct", rep("character", 2), rep("numeric", 3)
#                      , rep("qw", 16))
# name.qw <- "df"
#~~~~~~~~~~~~~~~~~~
# 03, MD Core Trends, Elgin Perry
class.df.single <- c("character", "POSIXct", "integer", "character", "numeric"
                     , rep("character", 3), "integer", "character", rep("qw", 26))
name.qw <- "ctall.fin"


```


```{r Example06_data2Reconstruct, eval=FALSE}
# Reconstruct dataCensored from parts
library(baytrends)
#

# Data File Creation Script

# Generate data
#
#{# 0. Prep####
# assume wd is package directory
#wd <- file.path(getwd(),"data-raw")
  

# If have to pick up code from here

myDir  
  

# 1. Generate Data####
# Reconstruct qw data set from parts
#
# Names
# myVar defined above

# Create DF
#DF <- data.frame(matrix("NA", nrow=7719, ncol=16))
#
# reapply classes from before saved as parts
  # class.df.single.header defined above
col.class.import <- gsub("qw", "character", class.df.single)
  col.class.import
DF <- read.table(file.path(myDir, paste0(name.qw,"_00All.csv")), sep=","
                 , header=TRUE, row.names = 1
                 , colClasses = "character"
                  )
str(DF)

# # import without classes
# DF <- read.table(file.path(myDir, paste0(name.qw,"_00All.csv")), sep=","
#                  , header=TRUE, row.names=1)
# str(DF)
# # most fields as factors.
# unlist(lapply(DF, class))

# set variables as those marked as "qw"
myVar <- names(DF)[grepl("qw", class.df.single)]

mySlotNames <- slotNames("qw")

# change to name.qw so output the correct item


#head(DF)
#
#
# non-character fields

# ## convert date to POSIXct class
# ### no TZ at this point
# col.class.import %in% "POSIXct"
# col.num.posixlt <- match("POSIXct", col.class.import)
#   col.num.posixlt
# DF[,col.num.posixlt] <- as.POSIXct(DF[,col.num.posixlt])
# str(DF)
# #

#~~~~~~~~~~~~~
# manual adjust
DF[,"date"] <- as.POSIXct(DF[,"date"])
str(DF)



#
# numeric
col.class.import.num <- col.class.import %in% "numeric"
col.numeric <- names(DF)[col.class.import.num]
  col.numeric
for (i in col.numeric){
  DF[,i] <- as.numeric(DF[,i])
}
str(DF)

# integer
col.class.import.int <- col.class.import %in% "integer"
col.integer <- names(DF)[col.class.import.int]
  col.integer
for (i in col.integer){
  DF[,i] <- as.integer(DF[,i])
}
str(DF)

#
# Convert to qw format
## loop through each variable and add info
slotNames("qw")
# mySlotNames <- c(".Data"
#                  , "remark.codes"
#                  , "value.codes"
#                  , "reporting.level"
#                  , "reporting.method"
#                  , "reporting.units"
#                  , "analyte.method"
#                  , "analyte.name"
#                  , "rounding"
#                  , "unique.code" 
#                  , "names") 

#
#i <- myVar[2]
#}
#
# QC
#myVar <- myVar[-2]


#
for (i in myVar) {##FOR.i.START
  #
  {
  i.num <- match(i, myVar)
  i.len <- length(myVar)
  #
  # Report Progress to User
  cat("\n\n")
  print(paste0("Processing; item i, ", i," (",i.num,"/",i.len,")."))
  flush.console()
  #
  # Load all slotname files
  # .Data
  #myName <- c("values","value2)")
  myFile <- file.path(myDir,paste(name.qw,i,mySlotNames[1],".csv",sep="_"))
    df.var.slot01 <- read.table(myFile, header=TRUE, row.names=1, sep=",")
  
  # remark.codes
  myName <- mySlotNames[2]
  myColClass <- "character"
  myFile <- file.path(myDir,paste(name.qw,i,mySlotNames[2],".csv",sep="_"))
    df.var.slot02 <- read.table(myFile, header=TRUE, row.names=1, sep=",", colClasses=myColClass, na.strings="NA")
    names(df.var.slot02) <- myName

  # value.codes
  # myName <- mySlotNames[3]
  # myColClass <- "character"
  # myFile <- file.path(wd,paste("dataCensored",i,mySlotNames[3],".csv",sep="_"))
  #   df.var.slot03 <- read.table(myFile, header=TRUE, row.names=1, sep=",", colClasses=myColClass)
  #   names(df.var.slot03) <- myName
  #
  # reporting.level
  # myName <- mySlotNames[4]
  # myColClass <- "character"
  # myFile <- file.path(wd,paste("dataCensored",i,mySlotNames[4],".csv",sep="_"))
  #   df.var.slot04 <- read.table(myFile, header=TRUE, row.names=1, sep=",", colClasses=myColClass)
  #   names(df.var.slot04) <- myName
  #
  # reporting.method
  # myName <- mySlotNames[5]
  # myColClass <- "character"
  # myFile <- file.path(wd,paste("dataCensored",i,mySlotNames[5],".csv",sep="_"))
  #   df.var.slot05 <- read.table(myFile, header=TRUE, row.names=1, sep=",", colClasses=myColClass)
  #   names(df.var.slot05) <- myName
  #
  # reporting.units
  # myName <- mySlotNames[6]
  # myColClass <- "character"
  # myFile <- file.path(wd,paste("dataCensored",i,mySlotNames[6],".csv",sep="_"))
  #   df.var.slot06 <- read.table(myFile, header=TRUE, row.names=1, sep=",", colClasses=myColClass)
  #   names(df.var.slot06) <- myName
  #
  # analyte.method
  # myName <- mySlotNames[7]
  # myColClass <- "character"
  # myFile <- file.path(wd,paste("dataCensored",i,mySlotNames[7],".csv",sep="_"))
  #   df.var.slot07 <- read.table(myFile, header=TRUE, row.names=1, sep=",", colClasses=myColClass)
  #   names(df.var.slot07) <- myName
  #
  # analyte.name
  # myName <- mySlotNames[8]
  # myColClass <- "character"
  # myFile <- file.path(wd,paste("dataCensored",i,mySlotNames[8],".csv",sep="_"))
  #   df.var.slot08 <- read.table(myFile, header=TRUE, row.names=1, sep=",", colClasses=myColClass)
  #   names(df.var.slot08) <- myName
  #
  # rounding
  # # Rounding is not included in as.qw (#09)
  # myName <- mySlotNames[9]
  # myColClass <- "numeric"
  # # myFile <- file.path(wd,paste("dataCensored",i,mySlotNames[9],".csv",sep="_"))
  # #   df.var.slot09 <- read.table(myFile, header=TRUE, row.names=1, sep=",", colClasses=myColClass)
  # #   names(df.var.slot09) <- myName
  #
  # unique.code
  # myName <- mySlotNames[10]
  # myColClass <- "character"
  # myFile <- file.path(wd,paste("dataCensored",i,mySlotNames[10],".csv",sep="_"))
  #   df.var.slot10 <- read.table(myFile, header=TRUE, row.names=1, sep=",", colClasses=myColClass)
  #   names(df.var.slot10) <- myName
  #
  # names
  # # names is not included in as.qw (#11)
  # myName <- mySlotNames[11]
  # myColClass <- "character"
  # # myFile <- file.path(wd,paste("dataCensored",i,mySlotNames[11],".csv",sep="_"))
  # #   df.var.slot11 <- read.table(myFile, header=TRUE, row.names=1, sep=",", colClasses=myColClass)
  # #   names(df.var.slot11) <- myName
  # #

  # combine
  df.var.slotData <- cbind(df.var.slot01, df.var.slot02 ) #, df.var.slot03
                           # , df.var.slot04, df.var.slot05, df.var.slot06
                           # , df.var.slot07, df.var.slot08, df.var.slot10)
  # remove to clear memory
  rm(df.var.slot01, df.var.slot02) #, df.var.slot03
      # , df.var.slot04, df.var.slot05, df.var.slot06
      # , df.var.slot07, df.var.slot08, df.var.slot10)

  slotNames("qw")
  getSlots("qw")
  showClass("qw")
   #, remark.codes     = df.var.slotData[,"remark.codes"]
   #                 , reporting.level  = NA
  }
  
  # add other slots into data frame.  Adding them below causes errors sometimes.
  # DF[,i] <- as.qw(values       =  df.var.slotData[,"values"]
  #                 , value2           = df.var.slotData[,"value2"]
  #                 , remark.codes     = ""
  #                 , value.codes      = ""
  #                 , reporting.level  = NA_real_
  #                 , reporting.method = ""
  #                 , reporting.units  = ""
  #                 , analyte.method   = ""
  #                 , analyte.name     = ""
  #                 , unique.code      = ""
  #                 )
  # #
    df.var.slotData[,"reporting.level"] <- NA_real_
    slots.NoData <- c("value.codes", "reporting.method", "reporting.units"
                      , "analyte.method", "analyte.name", "unique.code")
    df.var.slotData[, slots.NoData] <- ""
    #
  
    # the ctall.fin has NA mixed with the values (1 and 2) n=93 of 19971
    # create special statement.
    if (name.qw == "ctall.fin" & i=="cond") {##IF.name.qw.START
      # some have remark codes
      df.var.slotData[,"remark.codes"] <- 
      
      
      DF[,i] <- as.qw(values       =  as.numeric(df.var.slotData[,"values"])
                    , value2           = as.numeric(df.var.slotData[,"value2"])
                    , remark.codes     = df.var.slotData[,"remark.codes"] 
                    , value.codes      = df.var.slotData[,"value.codes"]
                    , reporting.level  = df.var.slotData[,"reporting.level"]
                    , reporting.method = df.var.slotData[,"reporting.method"]
                    , reporting.units  = df.var.slotData[,"reporting.units"]
                    , analyte.method   = df.var.slotData[,"analyte.method"]
                    , analyte.name     = df.var.slotData[,"analyte.name"]
                    , unique.code      = df.var.slotData[,"unique.code"]
                    )
    } else {
      DF[,i] <- as.qw(values       =  df.var.slotData[,"values"]
                    , value2           = df.var.slotData[,"value2"]
                    , remark.codes     = df.var.slotData[,"remark.codes"] 
                    , value.codes      = df.var.slotData[,"value.codes"]
                    , reporting.level  = df.var.slotData[,"reporting.level"]
                    , reporting.method = df.var.slotData[,"reporting.method"]
                    , reporting.units  = df.var.slotData[,"reporting.units"]
                    , analyte.method   = df.var.slotData[,"analyte.method"]
                    , analyte.name     = df.var.slotData[,"analyte.name"]
                    , unique.code      = df.var.slotData[,"unique.code"]
                    )
    }##IF.name.qw.END
    
    
    
    # myLen <- length(df.var.slotData[,"values"]) #ct.all is 19971
    # myRows <- 1:myLen
    # 
    #      DF[,i] <- as.qw(values       =  rep(999, myLen)
    #               , value2           =  rep(999, myLen)
    #               , remark.codes     = df.var.slotData[myRows,"remark.codes"] 
    #               , value.codes      = df.var.slotData[myRows,"value.codes"]
    #               , reporting.level  = df.var.slotData[myRows,"reporting.level"]
    #               , reporting.method = df.var.slotData[myRows,"reporting.method"]
    #               , reporting.units  = df.var.slotData[myRows,"reporting.units"]
    #               , analyte.method   = df.var.slotData[myRows,"analyte.method"]
    #               , analyte.name     = df.var.slotData[myRows,"analyte.name"]
    #               , unique.code      = df.var.slotData[myRows,"unique.code"]
    #               )
    # works so is an issue with the data not the code.

         
         
  #
  DF[,i]@rounding <- c(3,4)  # default is 2,3
  #
  # # define names
  # values.X <- df.var.slotData[,"values"]
  # N.X <- length(values.X)
  # names.X=as.character(seq(N.X))
  # DF[,i]@names <- as.character(seq(N.X))
  # str(DF)
  #View(#
}##FOR.i.END


##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 2. Save as RDA for use in package####
#
#dataCensored <- DF
#setwd("..")
#devtools::use_data(dataCensored, overwrite = TRUE)


str(DF)

```
Custom code for saving.  Otherwise all files are named DF.

Use value of name.qw

```{r SaveRDS, eval=FALSE}
#myFile.Out <- paste0(name.qw, ".rda")
myFile.Out <- gsub("_smwr", "_baytrends", fn)

#myFile.Out <- fn

#saveRDS(DF, myFile.Out)
# reuse file name from beginning.
# name.qw
# deparse(substitute(v1))
#assign(deparse(substitute(name.qw)), DF)

name.qw

# # 01, VA, Mike Lane
# myFile.Out <- gsub("_smwr", "_baytrends", fn)
# df <- DF
# save(df, file=myFile.Out)

# 03, MD Core Trends, Elgin Perry
ctall.fin <- DF
save(ctall.fin, file=myFile.Out)

#save(deparse(substitute(name.qw)), file=myFile.Out)
# save(DF, file=myFile.Out)

# make sure the thing is named by its own name rather then DF.
```



Reporting level in as.qw must be NA_real_ or the operation runs out of memory.

# 7. Read new file
Read the file back in with only `baytrends`.

```{r Read_BT_rds, eval=FALSE}
library(tcltk)
dir.qw.orig <- "C:\\Users\\Erik.Leppo\\OneDrive - Tetra Tech, Inc\\MyDocs_OneDrive\\ChesBay_R\\datasets_qw_convert"
fn <- tk_choose.files(default="dir.qw.orig", caption="Select smwr QW file to read")
#fn <- file.path(path.package("baytrends"), "extdata", "dataCensored__qw.rda")
# baytrends package must be loaded for path.package to work
#
# load qw object
load(fn)
name.qw <- load(fn, verbose=TRUE)
# assign to a generic name so can manipulate (reassign at end)
df.qw <- get(name.qw)
#
name.qw
str(df.qw)
```


# 8. Clean Up for Another Run

If repeating code need to detach `baytrends` or function references get messy when loading `smwrQW`.

Ctrl+L (in Windows) will clear the console.

Ctrl+Shft +F10 restarts R within RStudio.
```{r CleanUp, eval=FALSE}
detach(package:baytrends)
# wipe memory
rm(list=ls(all=TRUE))
# end any open graphics
#dev.off() # none in this code
# Clear the console (same as Ctrl+L on Windows)
cat("\014")
```

