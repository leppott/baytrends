---
title: "Vignette, QW"
author: "Erik.Leppo@tetratech.com"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette, QW}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
# Purpose
Early versions of the `baytrends` package relied on the `smwrQW` package for creating and using QW objects.  The `smwrQW` package has since been orphaned by its maintainer (USGS).  As such the capabilities to create and use a QW object have been ported from the `smwrQW` package into `baytrends`.  This vignette will guide users through the process to convert existing qw objects from the `smwrQW` package to the `baytrends` package (version 0.3.3.9011 or higher).

https://github.com/ldecicco-USGS/smwrQW

https://owi.usgs.gov/R/packages.html

You Will need an internet connection to follow the directions below.

# Process Overview
Will need to install the `smwrQW` package (and other smwr packages), load the packages.  Then load the object and export the parts.  After loading the object and exporting the parts the packages need to be removed.  Only then can `baytrends` be loaded and a new qw object created from the previously exported parts.

* Install and load `smwrQW` packages.
* Load qw object to convert.
* Save object parts.
* Remove `smwrQW` package from computer.
* Recreate qw object from parts as a `baytrends` object.

# Items to Automate
* File selection.
    + fname <- file.choose()
    + source(file.choose())
* Checking file "str()" and saving classes.
    + Classes easy.
    + Not sure what to do with things like date/time that come up as "character".
    + May have all the same columns?! 
    + If so that would be *much* easier to automate.
* Loading and removing packages.
    + Shouldn't be much of an issue.
* Dealing with unknown column headers.
    + Should be able to read and save.

# Example, dataCensored
Recreate dataCensored.  Save to pieces then recreate without smwrQW installed.

Original on 2017-12-20 did not export time zone.  Thus when Jon checked the file 2018-01-05 it was missing time zone information (mix of EDT and EST).  Need to export here with the time zone.

format(x, useTZ=TRUE)

switch to v3.4.1 of R to create parts.  OR install smwr* packages to extract the data then remove when build final data file.

Break out installing smwr packages as user may already have them installed.

```{r data0SaveHeader, eval=FALSE}

# detect if already installed.

# Install swmr packages (see above)
library(devtools)

install_github("USGS-R/smwrData")
# install.packages("digest")  # answer no
install_github("USGS-R/smwrBase")
install_github("USGS-R/smwrGraphs")
install_github("USGS-R/smwrStats")
install_github("USGS-R/smwrQW")





# File chooser to get file
# file.choose() is windows only.  Use tk_choose.files() for other systems.
fn <- file.choose()

# load dataCensored
# load("C:/Users/Erik.Leppo/OneDrive - Tetra Tech, Inc/MyDocs_OneDrive/ChesBay_R/dataCensored_data-raw/dataCensored_baytrends032.rda")
# #
load(fn)
name.qw <- load(fn, verbose=TRUE)

# Need to get name of object
#http://r.789695.n4.nabble.com/Assigning-a-new-name-to-object-loaded-with-quot-load-quot-td4638144.html

#library(baytrends)
library(smwrQW)  # load
#
str(get(name.qw))
#
# should have no errors in structure.




#~~~~~~~~~~~~~~~~~
# Need to replace dataCensored with get(name.qw)
# Not sure how works with $
#~~~~~~~~~~~~~~~~~






# 20180111, Ensure date explicitly includes time zone
#x <- format(dataCensored$date, format="%F %T", usetz=TRUE)
#
dataCensored$date <- format(dataCensored$date, format="%F %T", usetz = TRUE)

# Need export directory - file chooser ?
myDir <- choose.dir(default=file.path(getwd()), caption="Select folder for qw object parts.")
# library(tcltk)
# tk_choose.dir(getwd(), "Choose a suitable folder")
#myDir <- "C:\\Users\\Erik.Leppo\\OneDrive - Tetra Tech, Inc\\MyDocs_OneDrive\\ChesBay_R\\dataCensored_data-raw"

# Output 
# #
df.QW.no <- dataCensored[,1:3]
str(df.QW.no)
fn.header <- paste0(name.qw,"00Header.csv")
write.csv(df.QW.no, file.path(myDir, fn.header))
# #
# # have issues
# df.QW.yes <- as.data.frame(dataCensored[,4:16])
# 
fn.all <- paste0(name.qw,".csv")
write.csv(get(name.qw), file.path(myDir, fn.all))
# seems to have worked

# # Visual check
# x <- read.csv("dataCensored.csv")
# str(x)

myVar <- names(get(name.qw)[-(1:3)])
mySlotNames <- slotNames("qw")

# # To get slot data
# showClass("qw")
# slotNames("qw")
# 
# slot(dataCensored$secchi, "value.codes")

```


Extract dataCensored slot values

```{r data1SaveSlots, eval=FALSE}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Loop through and save all data
#library(baytrends) #needs smwrQW library to be present
library(swmwrQW)
myData <- get(name.qw)
myVar <- names(myData[-(1:3)])
mySlotNames <- slotNames("qw")
#
#
str(myData)
# #
df.QW.no <- myData[,1:3]
str(df.QW.no)
fn.header <- paste0(name.qw, "_00Header.csv")
write.csv(df.QW.no, file.path(myDir, fn.header))


#
for (i in myVar) {##FOR.i.START
  #
  i.num <- match(i, myVar)
  i.len <- length(myVar)
  #
  for (j in mySlotNames) {##FOR.j.START
    #
    j.num <- match(j, mySlotNames)
    j.len <- length(mySlotNames)
    #
    df.SlotValues <- slot(myData[,i],j)
    #
    myFile <- paste("dataCensored",i,j,".csv",sep="_")
    write.csv(df.SlotValues, file.path(myDir, myFile))
    #
    # Report Progress to User
    print(paste0("Saving; item i, ", i," (",i.num," of ",i.len,"), item j, ",j," (",j.num," of ",j.len,")."))
    flush.console()
    #
    }#FOR.j.END
  #
}##FOR.i.END

# Remove smwr* packages 
remove.packages("smwrData")
remove.packages("smwrQW")
remove.packages("smwrStats")
remove.packages("smwrGraphs")
remove.packages("smwrBase")
```

Reconstruct the qw data object

Ensure have latest version of `baytrends` package.
library(devtools)
install_github("leppott/baytrends")

```{r data2Reconstruct, eval=FALSE}
# Reconstruct dataCensored from parts
library(baytrends)
#
# Names
# **** Need to get programaticaly *****
# Should be the same as myVar
# myNames <- c("secchi"
#              , "chla"
#              , "do"
#              , "tn"
#              , "tp"
#              , "po4f"
#              , "pp"
#              , "tdp"
#              , "no23f"
#              , "nh4f"
#              , "tdn"
#              , "pn"
#              , "tss")

myNames <- myVar


# Create DF
#DF <- data.frame(matrix("NA", nrow=7719, ncol=16))
#names(DF) <- myNames
#fn.00 <- paste0(name.qw, "_00.csv")
fn.00 <- paste0(name.qw, "_00Header.csv")

DF <- read.table(file.path(myDir, fn.00), sep=","
                        , header=TRUE, row.names=1
                        , colClasses = "character"
                      )
str(DF)
head(DF)
#
# convert date to POSIXct class (add EST)
DF[,"date"] <- as.POSIXct(DF[,"date"],tz="EST")
str(DF)
head(DF)
#
# Convert to qw format


```

# Data File Creation Script
Have a separate R script in the "data-raw" folder for generating the "dataCensored" object for the baytrends package from the raw CSV files.

```{r dataraw_Generate, eval=FALSE}
# Generate data
#
# Erik.Leppo@tetratech.com
# 20171206
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ensure smwrQW package is not installed
remove.packages("smwrData")
remove.packages("smwrQW")
remove.packages("smwrStats")
remove.packages("smwrGraphs")
remove.packages("smwrBase")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

{# 0. Prep####
# assume wd is package directory
wd <- file.path(getwd(),"data-raw")

# 1. Generate Data####
# Reconstruct dataCensored from parts
library(baytrends)
#library(baytrends)  # need for as.qw to create class
#
# Names
  # **** Need to get programaticaly *****
myVar <- c("secchi"
             , "chla"
             , "do"
             , "tn"
             , "tp"
             , "po4f"
             , "pp"
             , "tdp"
             , "no23f"
             , "nh4f"
             , "tdn"
             , "pn"
             , "tss")
# Create DF
#DF <- data.frame(matrix("NA", nrow=7719, ncol=16))
#
DF <- read.table(file.path(wd,"dataCensored_00.csv"), sep=","
                 , header=TRUE, row.names=1
                 , colClasses = "character"
                  )
str(DF)
head(DF)
#
# convert date to POSIXct class (add EST)
#DF[,"date"] <- as.POSIXct(DF[,"date"],tz="EST")
DF[,"date"] <- as.POSIXct(DF[,"date"])
str(DF)
head(DF)
#
# Convert to qw format
## loop through each variable and add info
slotNames("qw")
mySlotNames <- c(".Data"
                 , "remark.codes"
                 , "value.codes"
                 , "reporting.level"
                 , "reporting.method"
                 , "reporting.units"
                 , "analyte.method"
                 , "analyte.name"
                 , "rounding"
                 , "unique.code" 
                 , "names") 

#
i <- myVar[1]
}
#
for (i in myVar) {##FOR.i.START
  #
  {
  i.num <- match(i, myVar)
  i.len <- length(myVar)
  #
  # Report Progress to User
  print(paste0("Processing; item i, ", i," (",i.num," of ",i.len,")."))
  flush.console()
  #
  # Load all slotname files
  #myName <- c("values","value2)")
  myFile <- file.path(wd,paste("dataCensored",i,mySlotNames[1],".csv",sep="_"))
    df.var.slot01 <- read.table(myFile, header=TRUE, row.names=1, sep=",")
    
  myName <- mySlotNames[2] 
  myColClass <- "character"
  myFile <- file.path(wd,paste("dataCensored",i,mySlotNames[2],".csv",sep="_"))
    df.var.slot02 <- read.table(myFile, header=TRUE, row.names=1, sep=",", colClasses=myColClass, na.strings="NA")
    names(df.var.slot02) <- myName
  
  # myName <- mySlotNames[3]  
  # myColClass <- "character" 
  # myFile <- file.path(wd,paste("dataCensored",i,mySlotNames[3],".csv",sep="_"))
  #   df.var.slot03 <- read.table(myFile, header=TRUE, row.names=1, sep=",", colClasses=myColClass)
  #   names(df.var.slot03) <- myName
  #   
  # myName <- mySlotNames[4]  
  # myColClass <- "character"
  # myFile <- file.path(wd,paste("dataCensored",i,mySlotNames[4],".csv",sep="_"))
  #   df.var.slot04 <- read.table(myFile, header=TRUE, row.names=1, sep=",", colClasses=myColClass)
  #   names(df.var.slot04) <- myName
  #   
  # myName <- mySlotNames[5]   
  # myColClass <- "character" 
  # myFile <- file.path(wd,paste("dataCensored",i,mySlotNames[5],".csv",sep="_"))
  #   df.var.slot05 <- read.table(myFile, header=TRUE, row.names=1, sep=",", colClasses=myColClass)
  #   names(df.var.slot05) <- myName
  # 
  # myName <- mySlotNames[6]  
  # myColClass <- "character"
  # myFile <- file.path(wd,paste("dataCensored",i,mySlotNames[6],".csv",sep="_"))
  #   df.var.slot06 <- read.table(myFile, header=TRUE, row.names=1, sep=",", colClasses=myColClass)
  #   names(df.var.slot06) <- myName
  # 
  # myName <- mySlotNames[7]  
  # myColClass <- "character"
  # myFile <- file.path(wd,paste("dataCensored",i,mySlotNames[7],".csv",sep="_"))
  #   df.var.slot07 <- read.table(myFile, header=TRUE, row.names=1, sep=",", colClasses=myColClass)
  #   names(df.var.slot07) <- myName
  # 
  # myName <- mySlotNames[8]  
  # myColClass <- "character"
  # myFile <- file.path(wd,paste("dataCensored",i,mySlotNames[8],".csv",sep="_"))
  #   df.var.slot08 <- read.table(myFile, header=TRUE, row.names=1, sep=",", colClasses=myColClass)
  #   names(df.var.slot08) <- myName
  #   
  # # Rounding is not included in as.qw (#09)
  # myName <- mySlotNames[9]  
  # myColClass <- "numeric"
  # # myFile <- file.path(wd,paste("dataCensored",i,mySlotNames[9],".csv",sep="_"))
  # #   df.var.slot09 <- read.table(myFile, header=TRUE, row.names=1, sep=",", colClasses=myColClass)
  # #   names(df.var.slot09) <- myName
  # 
  # myName <- mySlotNames[10]  
  # myColClass <- "character"
  # myFile <- file.path(wd,paste("dataCensored",i,mySlotNames[10],".csv",sep="_"))
  #   df.var.slot10 <- read.table(myFile, header=TRUE, row.names=1, sep=",", colClasses=myColClass)
  #   names(df.var.slot10) <- myName
  #   
  # # names is not included in as.qw (#11)
  # myName <- mySlotNames[11] 
  # myColClass <- "character"
  # # myFile <- file.path(wd,paste("dataCensored",i,mySlotNames[11],".csv",sep="_"))
  # #   df.var.slot11 <- read.table(myFile, header=TRUE, row.names=1, sep=",", colClasses=myColClass)
  # #   names(df.var.slot11) <- myName
  # #
    
  # combine
  df.var.slotData <- cbind(df.var.slot01, df.var.slot02 ) #, df.var.slot03
                           # , df.var.slot04, df.var.slot05, df.var.slot06
                           # , df.var.slot07, df.var.slot08, df.var.slot10)
  # remove to clear memory
  rm(df.var.slot01, df.var.slot02) #, df.var.slot03
      # , df.var.slot04, df.var.slot05, df.var.slot06
      # , df.var.slot07, df.var.slot08, df.var.slot10)

  slotNames("qw")
  getSlots("qw")
  showClass("qw")
  }
  DF[,i] <- as.qw(values       = df.var.slotData[,"values"]
                  , value2           = df.var.slotData[,"value2"]
                  , remark.codes     = df.var.slotData[,"remark.codes"]
                  , value.codes      = ""
                  , reporting.level  = NA_real_
                  , reporting.method = ""
                  , reporting.units  = ""
                  , analyte.method   = ""
                  , analyte.name     = ""
                  , unique.code      = ""
                  )
  #
  DF[,i]@rounding <- c(3,4)  # default is 2,3
  #
  # # define names
  # values.X <- df.var.slotData[,"values"]
  # N.X <- length(values.X)
  # names.X=as.character(seq(N.X))
  # DF[,i]@names <- as.character(seq(N.X))
  # str(DF)
  #View(#
}##FOR.i.END


##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 2. Save as RDA for use in package####
#
#dataCensored <- DF
#setwd("..")
#devtools::use_data(dataCensored, overwrite = TRUE)

saveRDS(DF, "xyz.rda")
# reuse file name from beginning.


```


Repeat code in a single block???????