# ####
#' Calculate GAM residuals 
#'
#' Use GAM analysis to compute residuals. Relies on mgcv::gam to perform general additive model.
#' 
#' @param df data frame
#' @param dep  variable
#' @param residualModel which gam formula is used to compute . Default: 'gam4'.
#' @param analySpec analytical specifications
#' @param gamTable gam table setting (set to FALSE to turn off table output)
#' @param gamPlot gam plot setting (set to FALSE to turn off plotting)
#' @param flow.detrended data generated by detrended.flow.  Default = NA.
#' @param salinity.detrended data generated by detrended.flow.  Default = NA.
#'
#' @return Returns a vector with results
#' @export
#'
# ####

createResiduals <- function(df, dep
                            , residualModel = 'gam4'
                            , analySpec = analySpec
                            , gamTable = FALSE
                            , gamPlot = FALSE
                            , flow.detrended = NA
                            , salinity.detrended = NA) {
  
# ----- Change history -------------------------------------------- ####
# 01Aug2018: JBH: migrated model loading to new function, loadModels. Added in
#                 a "fall back" option to use gam2 or gam4 if user had selected
#                 gam3 or gam5 and the model did not run (expected due to intervention)
# 30Jul2018: JBH: function renamed to createResiduals; extended to allow for
#                 any gam0-gam5 model
  
  
  # error trap: all variables present?
  {
    vars <- c(dep, "year", "doy", "dyear", "month", "nummon") 
    if (sum(vars %in% names(df)) <6) {
      warning(paste(" Variables not found: ", paste(vars[!vars %in% names(df)], collapse = ', ')))
      return(NA)
    }
  }
  
  # error trap: is  variable of qw type
  if (!class(df[,dep])=='qw') {
    warning(paste0("Variable not of qw class: ",dep))
    return(NA)
  }
  
  # error trap: evaluate gam model choice
  if (class(residualModel)=="list" ) {
    print(paste0("User specified model for computing residuals"))
    analySpec$gamModels <- residualModel
  }
  
  # set up computing residuals model ####
  if (class(residualModel)=="character") {
    if (residualModel %in% c('doy', 'gam0', 'gam1', 'gam2', 'gam3','gam4', 'gam5')) {
      analySpec$gamModels   <- loadModels(residualModel)
    }
  } else {
    warning(paste0("Valid model for computing residuals is not selected: ",residualModel))
    return(NA)
  }
  
  # print selected gam model ####
  if(gamTable | !gamPlot==FALSE) {  # only show header if tables or figures are outputted
    .H4(paste("Model: ",analySpec$gamModels[[1]]$model))
  }
  
  print(analySpec$gamModels[[1]]$model)
  
  # down select station list and layer list ####
  analySpec$stationList <- analySpec$stationList[analySpec$stationList$stations %in% unique(df$station),]
  analySpec$layerList <- analySpec$layerList[analySpec$layerList$layers %in% unique(df$layer),]

  # apply gam and compute residuals ####  
  stations  <- analySpec$stationList$stations
  layers    <- analySpec$layerList$layers
  
  for (layer in layers) { 
    for (stat in stations) { 
      # layer=layers[1]; stat=stations[1]
      # apply specified model
      .H4(paste("Processing: ",stat,"/",layer))
      gamModel.reset <- gamModel.orig  <- analySpec$gamModels[[1]]$option
      gamResult <- gamTest(df, dep, stat, layer, analySpec
                           , gamTable = gamTable
                           , gamPlot = gamPlot
                           , gamDiffModel = NA
                           , flow.detrended = flow.detrended
                           , salinity.detrended = salinity.detrended)
      
      # if model didn't run and model was gam3 or gam5, then drop back to gam 2 or gam4 and retry
      if (is.null(gamResult$stat.gam.result) & analySpec$gamModels[[1]]$option %in% c(3,5)) {
        .H4(paste("Processing: ",stat,"/",layer, ' -- dropping intervention term'))
        gamModel.reset <- gamModel.reset - 1
        analySpec$gamModels   <- loadModels(paste0('gam',gamModel.reset))
        gamResult <- gamTest(df, dep, stat, layer, analySpec
                             , gamTable = gamTable
                             , gamPlot = gamPlot
                             , gamDiffModel = NA
                             , flow.detrended = flow.detrended
                             , salinity.detrended = salinity.detrended) 
      }

      # collect computed residuals
      if (!is.na(gamResult[1])) { 
        residuals <- eval(parse(text = paste0("gamResult$gamOutput"
                                              , analySpec$gamModels[[1]]$option
                                              ,"$gamRslt$residuals")))
        dep.res0 <- cbind(gamResult$data[,c("station","date","layer")],residuals)
        if (!exists("dep.res1")) {
          dep.res1 <- dep.res0
        } else { 
          dep.res1 <- rbind(dep.res1, dep.res0)
        }
      }   
      
      # reset gamModel if necessary
      if (gamModel.orig != gamModel.reset) {
        analySpec$gamModels   <- loadModels(paste0('gam',gamModel.orig))
      }
      
    } # end stat loop
  } # end layer loop

  # merge residuals back to overall data frame ####  
  df <- merge(df,dep.res1, by=c("station","date","layer"), all.x=TRUE)
  
  return(df[,"residuals"])
}



